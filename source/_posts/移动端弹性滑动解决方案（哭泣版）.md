---
title: 移动端弹性滑动解决方案（哭泣版）
date: 2016-12-24 22:05:34
tags: javascript
categories: 技术
---

> 往往我们所唾弃的，其实都是自己想要的，只是拥有的那个人不是我们自己！

今天是西方人的**平安夜**，虽然不知道外国人是咋过的，但是在国内总是听到有人说今晚是一个炮火连天，血流成河的晚上，与‘平安夜’这个词完全不搭，吓得我此刻默默的拿起电脑在这写博客，感觉这样安全点（请让我先哭会...）。如果此刻还有和我一样猫在屋子里不敢出去，哭的死去活来的同时还在咒骂外面‘犯罪’的小伙伴的人，我送你们和我 两句话，第一句即为小标题中的那句话，慢慢体会，第二句是：请赶紧擦干眼泪，给明年的今天留点眼泪，这样的日子不止今天...(我再哭会...)。赶紧回到正题，要不真的生无可恋了。
前段时间同事做一个app 中运营位的功能，本来三两下就搞定了，因为我之前写好了各种方案可参考，但是呢产品说他需要一个可左右滚动浏览,想想也很简单，之前我在其他功能中也做了好多类似的案例，结果同事做完之后，测试发现在好多android机子上滚动起来就像便秘了一样，难受的要死，同事让我瞧的时候，我看了下，少了几个属性。如下：

    .box{
        overflow:auto;/* winphone8和android4+ */
        -webkit-overflow-scrolling: touch; /* ios5+ */
    }

基本上通过css来处理弹性滚动上面代码足以，这个时候你的滚动基本不会出现什么bug了，当然2.X的android机子我没试过，因为我们不支持4.X以下的。再加上下面这个隐藏掉滚动条，那简直就是完美：

    .box::-webkit-scrollbar {
        display: none;//隐藏滚动条
    }
    
请忽略winphone。具体效果可猛点 [这，对，使劲点](http://sadrun.duapp.com/demo/sem/download.html)  当然最好切换成手机模拟器，否则没效果哦。
通过css方式我目前只知道这一种，其他的css方式不知道，如果有人知道还请教教我这个小白。那么还有其他方式吗？答案是肯定的，有。不过下面的介绍的方式太过繁琐，像我这样的拿来主义真不想介绍，不过由于今晚是个特殊的日子，不多写点东西我真怕自己熬不过今晚，所以还是来简单说说。<!--more-->除了css方式实现某些效果之外我们当然还有熟悉的js,当然，如果你不想自己写，可以使用iscroll之类的框架，用起来相当简便，而且体验效果也是蛮不错的，毕竟是有团队维护的，具体使用方式可自行在github之类的地方找，我就不多赘述。好了，本文就在这结束了（裤子都脱了，就说了这么个解决方式？），仔细想了想，不行，时间还长，再耗一会。那就只能自己写一个弹性滑动了。
首先，我们来看下，：
手指按下——>滑动——>手指起来——>惯性滑动——>边界——>放慢滑行——>回弹。
整个过程基本就是这样，能不能写出对应功能代码不要紧，分清楚整个过程，就是成功了一大半了，写代码嘛，你不会写，就给会写的，你只要告诉整个流程，装装样子。前三个过程基本就是touch全家桶，start,move,end。抬起的时候这个时候就稍微复杂点，这个时候要知道惯性滑行的速度，要时刻控制速度，要不只能看着他飘向远方，直到飞出边界，我相信，产品绝对回来打死你。那么这个惯性速度怎么来初始化呢，很简单，你想定义多大就多大，不过最稳妥的方式是根据手指最后一个时间段移动的距离和时间来计算一个平均速度作为惯性滑动的初始速度，此处就不贴代码了，后面会放出整个代码。有了初速度，然后再给一个合理的减速度，让它慢慢的优雅的停下来就是我们的目标。惯性滑行的整个过程我们要注意一下边界，因为如果忽略边界，我们的box万一步子迈得太大，容易那个啥...所以，一定要关注一下，如果你试过原生的滚动，当我们拉到边界的未知的时候想把它拉出边界总是感觉有点吃力，所以我们也需要这种感觉，当我们的box跑到边界，但是他还没有停下来的意思的时候，我们就需要人为的给拉一把，让他早点回头，毕竟苦海无边，走远了，真的就回不来了。然后不断的给力让他停下，再停下的那一刻，他可能半只脚已在悬崖边了，所以，还需要再救救它，把它使劲拉回来，即就是回弹。然后整个过程就完成了，好简单啊（简单个p，代码一行都还没写出来呢。）
行文至此，基本解决方式都很明了了，代码都是小事，你不会写什么还可以随便找找，但是你不明白原理，写再多代码都是徒劳。小白我混了两年多前端，刚开始做功能就是无限的堆代码，一个功能分配下来，不管三七二十一，先码一堆代码再说，然后就会陷入无休止更改尝试，到做完之后，发现做了好多无用功，所以希望大家以后在前端中写代码的时候，都多想想，想到你自己都感觉这个方案很nice的时候，再去码代码，这个时候你会发现很快就能码出好多条理清晰的代码，功能很轻而易举的解决了，最终整个功能想的时间站一大半，代码只占一小部分。好了，在地震来临之前要早点睡。如果有什么好的问题，可以发邮件或者留言探讨，有什么不对的地方还请见谅，毕竟人家还是个小白（原谅矫情一下）。

----------------------------
上面方案代码如下，二百多行，已有注释，代码和解决思路没有做过优化，所以效果还是差好多，如果可以帮忙改进，感激不尽！

    /*
    * ISlide 
    *
    * 调用方式：
    * var target = document.getElementById('target');
    target.islide({
		dir:'X',//方向X:水平，Y:竖直方向
  		aspeed : 0.003 //加速度，越大缓动越小
    })
    *
    */
    (function(window){
    	"use strict";
    
      	var VERSION = "0.0.1";
      	var AUTHOR = '暮歌';
      	var rAF = window.requestAnimationFrame || window.webkitRequestAnimationFrame || function(callback) {
    		    setTimeout(callback, 16.6);
    	  	},
      		crAF =window.cancelAnimationFrame || window.webkitCancelAnimationFrame || function(id) {
    	    	clearTimeout(id);
      		};

	  	var ua = navigator.userAgent.toLowerCase();
	  	var preStyle = document.createElement('div').style;
	  	var prefix = (function(){
	  		var preNames = ["t", "webkitT", "MozT", "msT", "OT"],
	  			transform,
	  			i =preNames.length;

	  		while(i--){
	  			transform = preNames[i] + "ransform";
	  			if (transform in preStyle) return preNames[i];
	  		}
	  	})();

	    function touchmove(e){
	    	e.preventDefault();
	    }

	  	//实用工具
	  	var utils = {
	  		//兼容
		    TSF: prefix + "ransform",
		    TSD: prefix + "ransitionDuration",
		    TFO: prefix + "ransformOrigin",
		    isAndroid: /android/.test(ua),
		    isIOS: /iphone|ipad/.test(ua),
		    isMobile: /mobile|phone|android|pad/.test(ua),
		    prefix : prefix.substr(0, prefix.length - 1),

		    //判断浏览是否支持perspective属性，从而判断是否支持开启3D加速
		    translateZ: (function(pre) {
		      var f;
		      if (pre) {
		        f = pre + "Perspective" in preStyle;
		      } else {
		        f = "perspective" in preStyle;
		      }
		      return f ? " translateZ(0px)" : "";
		    })(prefix.substr(0, prefix.length - 1)),
		    extend:function(_default,custom){
		    	custom = custom || {};
		    	for(var key in _default){
		    		if(custom.hasOwnProperty(key)){
		    			_default[key] = custom[key];
		    		}
		    	}
		    	return _default;
		    },
		    throttle:function(delay,callback){
		    	var last,
		    		timer = null;
		    	return function(){
		    		var curr = Date.now(),
		    			context = this,
		    			args = arguments;
		    		crAF(timer);
		    		if(!last){
		    			last = curr;
		    		}
		    		if((curr - last) > delay){
		    			callback.apply(context,args);
		    			last = curr;
		    		}else{
		    			timer = rAF(function(){
		    				callback.apply(context,args);
		    			},delay);
		    		}
		    	}
		    },
		    //在指定时间内将指定元素从开始位置移到结束位置并执行回调方法
		    moveTo:function(){

		    }
	  	};
	  	//默认参数
	  	var defaultopts = {
	  		dir:'X',//方向X:水平，Y:竖直方向
	  		aspeed : 0.003 //加速度，越大缓动越小  	
		};
	  	function ISlide(target,options){
	  		this.target = target;
	  		this.init(options);
	  	}

	  	ISlide.prototype = {
	  		init:function(options){
	  			var me = this;
	  			me.opt = utils.extend(defaultopts,options);
	  			me.dir = me.opt.dir;
	  			me.flag = utils.throttle(16,function(args){
	  				me.go(args);
	  			}); //启动节流，从而减少绘制次数，进而防止卡顿

	  			me.clientWidth = (me.target.parentElement || me.target.parentNode).clientWidth;
	  			
	  			/*缓动相关参数*/
	  			me.slowMotion = false;
	  			me.lastMoveTime = 0;  
				me.lastMoveStart = 0;

	  			me.initEvent();
	  		},
	  		initEvent:function(){
	  			var me = this;
	  			var events = ['touchstart','touchmove','touchend','touchcancel'];
	  			events.forEach(function(event){
	  				me.target.addEventListener(event,function(e){
	  					me.handleEvent(e);
	  				},false);
	  			});
	  		},
	  		handleEvent:function(e){
	  			var me = this;
	  			switch(e.type){
	  				case 'touchstart':
	  					me.holdTouch();
	  					me.start(e);
	  					break;
	  				case 'touchmove':
	  					me.move(e);
	  					break;
	  				case 'touchend':
	  					me.end(e);
	  					me.unholdTouch();
	  					break;
	  				case 'touchcancel':
	  					me.cancel(e);
	  					break;
	  			}
	  		},
	  		start:function(e){
	  			var me = this;
	  			var targetTouche = e.targetTouches[0];
	  			me.startPos = me.endPos = targetTouche['page'+me.dir]; //手指起始位置
	  			var result =/translate\(([\-\d\.]+)px,\s+([\-\d\.]+)px\)/.exec(me.target.style[utils.TSF]);
	  			me.targetStartPos = (me.dir == 'X') ? (result ? result[1] : 0) : (result ? result[2] : 0);//目标元素起始位置
	  			me.targetWidth = me.target.scrollWidth;//目标元素宽度
	  			me.limitPos = -parseInt(me.targetWidth) + parseInt(me.clientWidth);//负方向临界值
	  			
	  			/*缓动参数赋值*/
	  			me.lastMoveTime = Date.now();  //计算缓动所需的起始时间
				me.lastMoveStart = me.endPos;  //计算缓动所需的起始位置
	  		},
	  		move:function(e){
	  			var me = this;
	  			me['nowpos'+me.dir] = e.targetTouches[0]['page'+me.dir]; //当前手指的位置
	  			me.movePos = parseFloat(me.targetStartPos) + (parseFloat(me['nowpos'+me.dir]) - parseFloat(me.startPos));//当前元素的位置

	  			me.flag(me.movePos); //加入绘制的队列
	  			
	  			var nowTime = Date.now(); 
	  			if((nowTime - me.lastMoveTime) > 300){//每隔300毫秒重新计算一次缓动参数
	  				me.lastMoveTime = nowTime;
	  				me.lastMoveStart = me['nowpos'+me.dir];
	  			}
	  		},
	  		end:function(e){
	  			var me = this;
	  			var nowTime = Date.now();
	  			var v = ((parseInt(me['nowpos'+me.dir]) - parseInt(me.lastMoveStart)) / (parseInt(nowTime) - parseInt(me.lastMoveTime))).toFixed(3);//缓动初始速度

	  			me.slowM(v,nowTime);//执行缓动
	  		},
	  		cancel:function(e){

	  		},
	  		go:function(pos){
	  			var me = this;
	  			if(pos > 0){//大于0，则控制移动距离
	  				pos = pos/10;
	  				me.movePos = pos; 
	  				me.Limiting = -1;
	  			}
	  			else if(me.limitPos> pos ){//超出临界值时控制移动距离
	  				pos = me.limitPos - (me.limitPos-pos)/10;
	  				me.movePos = pos;
	  				me.Limiting = 1;
	  			}else{
	  				me.Limiting = 0;
	  			}
	  			me.target.style[utils.TSF] = 'translate(' + (me['nowposX'] ? pos : 0) + 'px, ' + (me['nowposY'] ? pos : 0) + 'px)' + utils.translateZ ;
	  		},
	  		slowM:function(v,startTime){
	  			var me = this;
	  			var a_dir = v > 0 ? -1 : 1; //加速度方向，与当前滑动方向相反
	  			var a = a_dir*me.opt.aspeed; //加速度
	  			var slowDistance = v*v/(2*a); //缓动距离

	  			slowMgo();
	  			var timer = null;//缓动时的定时器
	  			var limitTimer = null;//回弹时的定时器

	  			function slowMgo(){
	  				var nowTime =Date.now();
	  				var t = nowTime-startTime;
	  				startTime = nowTime;
	  				var nowV = (parseFloat(v) + parseFloat(t*a)).toFixed(3);

	  				if(a_dir*nowV > 0) { //如果有超出两个临界值，则执行回弹
	  					crAF(timer);
	  					if(me.Limiting != 0){
	  						limitgo();
	  					}
		                return;  
		            }

		            var currmove = (parseFloat(v) + parseFloat(nowV)).toFixed(3)/2 * t;
		            v = nowV;
		            me.movePos += currmove;
		            me.go(me.movePos); 
	            	timer = rAF(slowMgo); 
	  			}
	  			function limitgo(){
	  				if(parseInt(me.movePos) == 0 || parseInt(me.movePos) == me.limitPos){
	  					crAF(limitTimer);
	  					return;
	  				}
	  				me.movePos += me.Limiting*1;
	  				me.target.style[utils.TSF] = 'translate(' + (me['nowposX'] ? me.movePos : 0) + 'px, ' + (me['nowposY'] ? me.movePos : 0) + 'px)' + utils.translateZ ;
	  				limitTimer = rAF(limitgo);
	  			}
	  		},
	  		holdTouch:function (){//组织浏览器默认行为
		    	document.addEventListener('touchmove', touchmove);
		    },
		    unholdTouch:function() {//放开浏览器默认行为
		        document.removeEventListener('touchmove', touchmove);
		    },
		    version:VERSION,
		    utils:utils,
		    author:AUTHOR
	  	};

	  	Element.prototype.islide = function(option) {
	        return new ISlide(this, option);
	    };//将该方法绑定在元素上。此处形式多样，可自行选择。
	})(window);



